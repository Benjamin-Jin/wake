# Read the file contents of a Path
global def read path =
  def imp p = prim "read"
  imp path.getPathName

# Simplify away the ..s and .s in a String
global def simplify path = prim "simplify"

# Reframe path into a form accesible relative to dir
global def relative dir path = prim "relative"

# Locate an executable in the search path
global def whichIn path exec = memoize 0 (
  def imp path exec = prim "search_path"
  imp path exec
)

global def which exec = whichIn path exec
global def workspace = prim "workspace"

def mkdirRunner =
  def imp m p = prim "mkdir"
  def pre input =
    match input.getRunnerInputCommand
      _, _, mode, dir, Nil = Pair input (Pair mode dir)
      _ = raise "mkdirRunner: invalid command-line"
  def post (Pair output (Pair mode dir)) =
    output
    | editRunnerOutputOutputs (imp (int mode) dir, _)
  makeRunner pre post virtualRunner

# Create a directory (if it does not already exist)
global def mkdir mode path =
  def helper (Pair inputs acc_) e =
    def acc = if acc_ ==* "" then if e ==* "" then "/" else e else simplify "{acc_}/{e}"
    makePlan ("<mkdir>", "-m", str mode, acc, Nil) inputs
    | setPlanRunner      mkdirRunner
    | setPlanKeep        False
    | setPlanEnvironment Nil
    | runJob
    | getJobOutputs
    | (Pair _ acc)
  foldl helper (Pair Nil "") (path | simplify | tokenize "/") | getPairFirst | head

global def write mode path content =
  def writeRunner =
    def imp m p c = prim "write"
    def pre input = Pair input Unit
    def post (Pair output Unit) =
      output
      | editRunnerOutputOutputs (imp mode path.simplify content, _)
    makeRunner pre post virtualRunner
  def exec = or mode ((and mode 0444) >> 2) # copy read permissions to execute permissions
  makePlan ("<write>", str mode, path, Nil) (mkdir exec "{path}/..".simplify, Nil)
  | setPlanRunner      writeRunner
  | setPlanOnce        False
  | setPlanEnvironment Nil
  | runJob
  | getJobOutput
