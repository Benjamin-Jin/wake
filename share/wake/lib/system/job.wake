# A Runner describes a way to invoke a Plan to get a Job
global tuple Runner =
  global Fn RunnerInput => RunnerOutput

# RunnerInput is a subset of the fields supplied in the execution Plan
tuple RunnerInput =
  global Job           Job
  global CommandLine   List String
  global Visible       List Path
  global Environment   List String
  global Directory     String
  global StandardInput String
  Pool                 Integer

tuple RunnerOutput =
  global Inputs  List String
  global Outputs List String
  global Indexes List String

global def makeRunnerOutput Unit =
  RunnerOutput Nil Nil Nil

# A Plan describes a not-yet-executed Job
tuple Plan =
  global Command       List String  # The command-line arguments (the first is the command to run)
  global Visible       List Path    # Only these files should be available to the command
  global Environment   List String  # KEY=VALUE environment variables fed to the command
  global Directory     String       # The directory in which the command should be run
  global StandardInput String       # The file to which standard input should be connected
  Once_                Boolean      # Should Job only be run once in a given wake execution
  Keep_                Boolean      # Should Job output be reusable between wake invocations
  Share_               Boolean      # Should Job output be shared between workspaces
  global Runner        Runner       # The runner to use when executing this job
  global FnInputs      (List String => List String) # Modify the Runner's reported inputs  (files read)
  global FnOutputs     (List String => List String) # Modify the Runner's reported outputs (files created)
  global FnIndexes     (List String => List String) # Modify the Runner's reported indexes (directories listed)
  Pool                 Integer      # Resource pool used to pay for the Job

global def getPlanOnce  = getPlanOnce_
global def getPlanKeep  = getPlanKeep_
global def getPlanShare = getPlanShare_
global def editPlanOnce  f p = setPlanOnce  (f p.getPlanOnce_)
global def editPlanKeep  f p = setPlanKeep  (f p.getPlanKeep_)
global def editPlanShare f p = setPlanShare (f p.getPlanShare_)

# Maintain the invariant that: Share => Keep => Once
global def setPlanOnce v p =
  if v
  then p | setPlanOnce_ True
  else p | setPlanOnce_ False | setPlanKeep_ False | setPlanShare_ False
global def setPlanKeep v p =
  if v
  then p | setPlanOnce_ True  | setPlanKeep_  True
  else p | setPlanKeep_ False | setPlanShare_ False
global def setPlanShare v p =
  if v
  then p | setPlanOnce_ True | setPlanKeep_ True | setPlanShare_ True
  else p | setPlanShare_ False

# The criteria which determine if Job execution can be skipped:
#   Once  is True and a matching job was run by this wake invocation
#   Keep  is True and there is matching output in the workspace
#   Share is True and there is matching output in a shared cache
# A Job is considered matching if:
#   The Command, Environment, Directory, and StandardInput are exact matches
#   FnInputs, FnOutputs, FnIndexes have the same hashcode
# Output is considered matching if:
#   The prior Outputs exist as the output of a matching Job
#   The prior Inputs have the same hashes as files in the workspace
#   The prior Indexes observe the same set of Visible files

# Set reasonable defaults for all Plan arguments
def id x = x
global def makePlan cmd visible =
  Plan cmd visible environment "." "" True True True fuseRunner id id id 1

global def makeManualPlan cmd visible foutputs =
  Plan cmd visible environment "." "" True True True manualRunner id (\_ foutputs Unit) id 1

def makeRawPlan cmd  =
  Plan cmd Nil Nil "." "" False False False manualRunner id id id 1

# This runner does not detect inputs/outputs/indexes on it's own
# You must use Fn{Inputs,Outputs,Indexes} to fill in this information
global def manualRunner =
  def launch job pool dir stdin env cmd = prim "job_launch"
  def doit in = match in
    RunnerInput job cmd vis env dir stdin pool =
      def ok = launch job pool dir stdin env.implode cmd.implode
      def out = RunnerOutput (map getPathName vis) Nil Nil
      def handle _ = match (virtualRunner (\_ out))
        Runner run = run in
      tryelse handle (\_ out) ok
  Runner doit

global def virtualRunner fn =
  def virtual job stdout stderr status runtime = prim "job_virtual"
  def doit in =
    def out = fn in
    match (try (\x RunnerOutput x Nil Nil) out)
      RunnerOutput inputs outputs indexes =
        def fails = tryelse (_) (\_ Nil)
        def exceptions = inputs ++ outputs ++ indexes | map fails | flatten
        def stderr = catWith "\n" exceptions
        def status = if exceptions.empty then 0 else 1
        def _ = virtual in.getRunnerInputJob "" stderr status 0.0
        if exceptions.empty
        then out
        else RunnerOutput (map getPathName in.getRunnerInputVisible) Nil Nil
  Runner doit

def implode l = cat (foldr (_, "\0", _) Nil l)
def runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool =
  def create dir stdin env cmd = prim "job_create"
  def finish job inputs outputs = prim "job_finish"
  def cache dir stdin env cmd visible = prim "job_cache"
  def build _ =
    def job = create dir stdin env.implode cmd.implode
    def input = RunnerInput job cmd vis env dir stdin pool
    match (run input)
      RunnerOutput inputs outputs indexes =
        def final _ =
          def input  = finputs  inputs  | map hashname | implode
          def output = foutputs outputs | map hashname | implode
          finish job input output
        def _ = waitOne final job.getJobStatus
        job
  match keep
    False = build 0
    True  = match (tryelse (\_ None) (Some _) (cache dir stdin env.implode cmd.implode (map getPathName vis).implode))
      None     = build 0
      Some out =
        def notOk (Pair name hash) = hashcode name !=* hash
        match (find notOk (tree out 2))
          None = out
          Some (Pair (Pair file saw) _) =
            raise "Hash mismatch for {file} ({saw} != {hashcode file}); remove it"

# Only run if the first four arguments differ
def runOnce cmd env dir stdin finputs foutputs findexes vis keep share run pool =
  memoize 9 (runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool)

# Run the job!
global def runJob (Plan cmd vis env dir stdin once keep share (Runner run) finputs foutputs findexes pool) =
  if once
  then runOnce   cmd env dir stdin finputs foutputs findexes vis keep share run pool
  else runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool

# Control a running/finished Job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
def fail job ok = if job.getJobStatus == 0 then ok else raise "Non-zero exit status ({job.getJobStatus})"
global def killJob job signal = prim "job_kill" # s != 0 => kills; blocks till exit; return status
global def getJobStatus  job = killJob  job 0
global def getJobStdout  job = stdio job 1
global def getJobStderr  job = stdio job 2
global def getJobInputs  job = fail job job.getJobRawInputs
global def getJobOutputs job = fail job job.getJobRawOutputs
global def getJobRawInputs  job = tree job 1 | map getPairFirst | map makePath
global def getJobRawOutputs job = tree job 2 | map getPairFirst | map makePath
global def getJobOutput = match _.getJobOutputs
  x, Nil = x
  Nil    = raise "no outputs available"
  _      = raise "more than one output found"

# Implement FUSE-based Runner
def wakePath = prim "execpath" # location of the wake executable
def fusePath = relative workspace (simplify "{wakePath}/../lib/wake/fuse-wake")
global def fuseRunner =
  def doit in =
    def cmd = fusePath, in.getRunnerInputDirectory, in.getRunnerInputVisible | map getPathName
    def fuse = makeRawPlan cmd | setPlanPool 0 | runJob
    def handle = raise "Could not start fuse-wake: {_}"
    def root = try handle (extract 'OK: (.*)' fuse.getJobStderr)
    def result = extract "(.*\0)?\0(.*)" fuse.getJobStdout
    def inputs  = result | at 0 | tokenize "\0" | reverse | tail
    def outputs = result | at 1 | tokenize "\0" | reverse | tail
    def out =
      in
      | editRunnerInputDirectory ("{root.head}/{_}")
      | manualRunner.getRunnerFn
      | setRunnerOutputInputs  inputs
      | setRunnerOutputOutputs outputs
    def final _ = killJob fuse 14 # SIGALRM
    def _ = waitOne final in.getRunnerInputJob.getJobStatus
    out
  Runner doit

# Paths differ from Strings in that they have been hashed; their content is frozen
data Path = Path String
global def getPathName (Path name) = name

# Convert a file name into a path.
# If you use this method, name must never be an output of a Job.
global def makePath name = Path (hashname (simplify name))

def hashname f = hashpair f | getPairFirst  # just the filename
def hashcode f = hashpair f | getPairSecond # just the hashcode
def hashpair f = memoize 0 ( # Pair file hash
  def get f = prim "get_hash"
  def add f h = prim "add_hash"
  def reuse = get f
  if reuse !=* "" then add f reuse else
    def job = makeRawPlan ("<hash>", f, Nil) | runJob
    if job.getJobStatus == 0
    then extract '(.{64}).*' job.getJobStdout | head | add f
    else raise "Failed to hash file {f}"
)

global def write mode path content =
  def imp m p c = prim "write"
  makePath (imp mode path content)

# Create a directory (if it does not already exist)
global def mkdir mode rawpath =
  def path = simplify rawpath
  def imp m p = prim "mkdir"
  def doit _ = RunnerOutput Nil (imp mode path, Nil) Nil
  makePlan ("<mkdir>", path, Nil) Nil
  | setPlanRunner      (virtualRunner doit)
  | setPlanKeep        False
  | setPlanEnvironment Nil
  | runJob
  | getJobOutput

# Whenever possible, use 'job' if:
#   cmd can run under FUSE
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   gcc
# job only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def job cmd visible =
  makePlan cmd visible
  | runJob

# Use alwaysJob when:
#   cmd can run under FUSE
#   cmd output can differ between invocations
# Examples:
#   date
# alwaysJob only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def alwaysJob cmd visible =
  makePlan cmd visible
  | setPlanKeep False
  | runJob

# Use manualJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   vcs
# cmd will have access to the entire workspace.
# manualJob behaves like normal target rule in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may be rerun and wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def manualJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | runJob

# Use volatileJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd output can differ between invocations
# Examples:
#   ???
# volatileJob behaves like a PHONY target in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def volatileJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | setPlanKeep False
  | runJob
