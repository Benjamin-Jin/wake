# A Runner describes a way to invoke a Plan to get a Job
global tuple Runner =
  global Fn RunnerInput => RunnerOutput

# RunnerInput is a subset of the fields supplied in the execution Plan
tuple RunnerInput =
  global CommandLine   List String
  global Visible       List Path
  global Environment   List String
  global Directory     String
  global StandardInput String
  Pool                 Integer
  Root                 String

tuple RunnerOutput =
  global Job     Job
  # these might be futures:
  global Inputs  List String
  global Outputs List String
  global Indexes List String

global def makeRunnerOutput job =
  RunnerOutput job Nil Nil Nil

# A Plan describes a not-yet-executed Job
tuple Plan =
  global Command       List String  # The command-line arguments (the first is the command to run)
  global Visible       List Path    # Only these files should be available to the command
  global Environment   List String  # KEY=VALUE environment variables fed to the command
  global Directory     String       # The directory in which the command should be run
  global StandardInput String       # The file to which standard input should be connected
  global Once          Boolean      # Should Job only be run once in a given wake execution
  global Keep          Boolean      # Should Job output be reusable between wake invocations
  global Share         Boolean      # Should Job output be shared between workspaces
  global Runner        Runner       # The runner to use when executing this job
  global FnInputs      (List String => List String) # Modify the Runner's reported inputs  (files read)
  global FnOutputs     (List String => List String) # Modify the Runner's reported outputs (files created)
  global FnIndexes     (List String => List String) # Modify the Runner's reported indexes (directories listed)
  Pool                 Integer      # Resource pool used to pay for the Job
  Root                 String       # Workspace root directory used by the Job

# The criteria which determine if Job execution can be skipped:
#   Once  is True and a matching job was run by this wake invocation
#   Keep  is True and there is matching output in the workspace
#   Share is True and there is matching output in a shared cache
# A Job is considered matching if:
#   The Command, Environment, Directory, and StandardInput are exact matches
#   FnInputs, FnOutputs, FnIndexes have the same hashcode
# Output is considered matching if:
#   The prior Outputs exist as the output of a matching Job
#   The prior Inputs have the same hashes as files in the workspace
#   The prior Indexes observe the same set of Visible files
# Note: Once=False => Keep=False => Share=False

# Set reasonable defaults for all Plan arguments
def id x = x
global def makePlan cmd visible =
  Plan cmd visible environment "." "" True True True fuseRunner id id id 1 "."

global def makeManualPlan cmd visible foutputs =
  Plan cmd visible environment "." "" True True True manualRunner id (\_ foutputs Unit) id 1 "."

def makeRawPlan cmd  =
  Plan cmd Nil Nil "." "" False False False manualRunner id id id 1 "."

# This runner does not detect inputs/outputs/indexes on it's own
# You must use Fn{Inputs,Outputs,Indexes} to fill in this information
global def manualRunner =
  def launch pool root dir stdin env cmd = prim "job_launch"
  def doit (RunnerInput cmd vis env dir stdin pool root) =
    def job = launch pool root dir stdin env.implode cmd.implode
    RunnerOutput job (map getPathName vis) Nil Nil
  Runner doit

def implode l = cat (foldr (_, "\0", _) Nil l)
def runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool root =
  def finish job inputs outputs = prim "job_finish"
  def cache dir stdin env cmd visible = prim "job_cache"
  def input = RunnerInput cmd vis env dir stdin pool root
  def build _ = match (run input)
    RunnerOutput job inputs outputs indexes =
      def final _ =
        def input  = finputs  inputs  | map hashname | implode
        def output = foutputs outputs | map hashname | implode
        finish job input output
      def _ = waitOne final job.getJobStatus
      job
  match keep
    False = build 0
    True  = match (tryelse (\_ None) (Some _) (cache dir stdin env.implode cmd.implode (map getPathName vis).implode))
      None     = build 0
      Some out =
        def notOk (Pair name hash) = hashcode name !=* hash
        match (find notOk (tree out 2))
          None = out
          Some (Pair (Pair file saw) _) =
            raise "Hash mismatch for {file} ({saw} != {hashcode file}); remove it"

# Only run if the first four arguments differ
def runOnce cmd env dir stdin finputs foutputs findexes vis keep share run pool root =
  memoize 9 (runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool root)

# Run the job!
global def runJob (Plan cmd vis env dir stdin once keep share (Runner run) finputs foutputs findexes pool root) =
  def keep_  = once && keep
  def share_ = keep_ && share
  if once
  then runOnce   cmd env dir stdin finputs foutputs findexes vis keep_ share_ run pool root
  else runAlways cmd env dir stdin finputs foutputs findexes vis keep_ share_ run pool root

# Control a running/finished Job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
def fail job ok = if job.getJobStatus == 0 then ok else raise "Non-zero exit status ({job.getJobStatus})"
global def killJob job signal = prim "job_kill" # s != 0 => kills; blocks till exit; return status
global def getJobStatus  job = killJob  job 0
global def getJobStdout  job = stdio job 1
global def getJobStderr  job = stdio job 2
global def getJobInputs  job = fail job job.getJobRawInputs
global def getJobOutputs job = fail job job.getJobRawOutputs
global def getJobRawInputs  job = tree job 1 | map getPairFirst | map makePath
global def getJobRawOutputs job = tree job 2 | map getPairFirst | map makePath
global def getJobOutput = match _.getJobOutputs
  x, Nil = x
  Nil    = raise "no outputs available"
  _      = raise "more than one output found"

# Implement FUSE-based Runner
def wakePath = prim "execpath" # location of the wake executable
def fusePath = relative workspace (simplify "{wakePath}/../lib/wake/fuse-wake")
global def fuseRunner =
  def doit in =
    def cmd = fusePath, in.getRunnerInputDirectory, in.getRunnerInputVisible | map getPathName
    def fuse = makeRawPlan cmd | setPlanPool 0 | runJob
    def handle = raise "Could not start fuse-wake: {_}"
    def root = try handle (extract 'OK: (.*)' fuse.getJobStderr)
    def result = extract "(.*\0)?\0(.*)" fuse.getJobStdout
    def inputs  = result | at 0 | tokenize "\0" | reverse | tail
    def outputs = result | at 1 | tokenize "\0" | reverse | tail
    def out =
      in
      | setRunnerInputRoot root.head
      | manualRunner.getRunnerFn
      | setRunnerOutputInputs  inputs
      | setRunnerOutputOutputs outputs
    def final _ = killJob fuse 14 # SIGALRM
    def _ = waitOne final out.getRunnerOutputJob.getJobStatus
    out
  Runner doit

# Paths differ from Strings in that they have been hashed; their content is frozen
data Path = Path String
global def getPathName (Path name) = name

# Convert a file name into a path.
# If you use this method, name must never be an output of a Job.
global def makePath name = Path (hashname (simplify name))

def hashname f = hashpair f | getPairFirst  # just the filename
def hashcode f = hashpair f | getPairSecond # just the hashcode
def hashpair f = memoize 0 ( # Pair file hash
  def get f = prim "get_hash"
  def add f h = prim "add_hash"
  def reuse = get f
  if reuse !=* "" then add f reuse else
    def job = makeRawPlan ("<hash>", f, Nil) | runJob
    if job.getJobStatus == 0
    then extract '(.{64}).*' job.getJobStdout | head | add f
    else raise "Failed to hash file {f}"
)

global def write mode path content =
  def imp m p c = prim "write"
  makePath (imp mode path content)

global def mkdir mode path =
  def imp m p = prim "mkdir"
  Path (imp mode path)

# Whenever possible, use 'job' if:
#   cmd can run under FUSE
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   gcc
# job only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def job cmd visible =
  makePlan cmd visible
  | runJob

# Use alwaysJob when:
#   cmd can run under FUSE
#   cmd output can differ between invocations
# Examples:
#   date
# alwaysJob only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def alwaysJob cmd visible =
  makePlan cmd visible
  | setPlanKeep False
  | runJob

# Use manualJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   vcs
# cmd will have access to the entire workspace.
# manualJob behaves like normal target rule in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may be rerun and wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def manualJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | runJob

# Use volatileJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd output can differ between invocations
# Examples:
#   ???
# volatileJob behaves like a PHONY target in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def volatileJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | setPlanKeep False
  | runJob
