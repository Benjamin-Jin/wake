tuple Usage =
  global Status   Integer
  global Runtime  Double
  global CPUtime  Double
  global MemBytes Integer
  global InBytes  Integer
  global OutBytes Integer

# RunnerInput is a subset of the fields supplied in the execution Plan
tuple RunnerInput =
  global Command       List String
  global Visible       List Path
  global Environment   List String
  global Directory     String
  global StandardInput String
  global Record        Option Usage
  Pool                 Integer

tuple RunnerOutput =
  global Inputs  List String
  global Outputs List String
  global Indexes List String
  global Usage   Usage

# A Runner describes a way to invoke a Plan to get a Job
tuple Runner =
  Fn Job => RunnerInput => RunnerOutput

# Create new Runner given pre- and post-hooks around an existing Runner
global def makeRunner pre post (Runner run) =
  def doit job preInput =
    def preOutput = pre preInput
    # Ensure that match does not re-raise the exception; must invoke run!
    match (try (\_ Pair (cast preOutput) (cast preOutput)) preOutput)
      Pair runInput state =
        def runOutput = run job runInput
        def final _ = post (Pair runOutput state)
        # Don't run any 'post' steps until the Job has stopped running
        waitJobMerged final job
  Runner doit

# A Plan describes a not-yet-executed Job
tuple Plan =
  global Command       List String  # The command-line arguments (the first is the command to run)
  global Visible       List Path    # Only these files should be available to the command
  global Environment   List String  # KEY=VALUE environment variables fed to the command
  global Directory     String       # The directory in which the command should be run
  global StandardInput String       # The file to which standard input should be connected
  Once_                Boolean      # Should Job only be run once in a given wake execution
  Keep_                Boolean      # Should Job output be reusable between wake invocations
  Share_               Boolean      # Should Job output be shared between workspaces
  global Runner        Runner       # The runner to use when executing this job
  global FnInputs      (List String => List String) # Modify the Runner's reported inputs  (files read)
  global FnOutputs     (List String => List String) # Modify the Runner's reported outputs (files created)
  global FnIndexes     (List String => List String) # Modify the Runner's reported indexes (directories listed)
  Pool                 Integer      # Resource pool used to pay for the Job

global def getPlanOnce  = getPlanOnce_
global def getPlanKeep  = getPlanKeep_
global def getPlanShare = getPlanShare_
global def editPlanOnce  f p = setPlanOnce  (f p.getPlanOnce_)
global def editPlanKeep  f p = setPlanKeep  (f p.getPlanKeep_)
global def editPlanShare f p = setPlanShare (f p.getPlanShare_)

# Maintain the invariant that: Share => Keep => Once
global def setPlanOnce v p =
  if v
  then p | setPlanOnce_ True
  else p | setPlanOnce_ False | setPlanKeep_ False | setPlanShare_ False
global def setPlanKeep v p =
  if v
  then p | setPlanOnce_ True  | setPlanKeep_  True
  else p | setPlanKeep_ False | setPlanShare_ False
global def setPlanShare v p =
  if v
  then p | setPlanOnce_ True | setPlanKeep_ True | setPlanShare_ True
  else p | setPlanShare_ False

# The criteria which determine if Job execution can be skipped:
#   Once  is True and a matching job was run by this wake invocation
#   Keep  is True and there is matching output in the workspace
#   Share is True and there is matching output in a shared cache
# A Job is considered matching if:
#   The Command, Environment, Directory, and StandardInput are exact matches
#   FnInputs, FnOutputs, FnIndexes have the same hashcode
# Output is considered matching if:
#   The prior Outputs exist as the output of a matching Job
#   The prior Inputs have the same hashes as files in the workspace
#   The prior Indexes observe the same set of Visible files

# Set reasonable defaults for all Plan arguments
def id x = x
global def makePlan cmd visible =
  Plan cmd visible environment "." "" True True True fuseRunner id id id 1

global def makeManualPlan cmd visible foutputs =
  Plan cmd visible environment "." "" True True True manualRunner id (\_ foutputs Unit) id 1

def makeRawPlan cmd  =
  Plan cmd Nil Nil "." "" False False False manualRunner id id id 1

def defaultUsage = Usage 0 0.0 0.0 0 0 0

# This runner does not detect inputs/outputs/indexes on it's own
# You must use Fn{Inputs,Outputs,Indexes} to fill in this information
global def manualRunner =
  def launch job pool dir stdin env cmd status runtime cputime membytes ibytes obytes = prim "job_launch"
  def doit job input =
   # Ensure that match does not re-raise the exception (launch must run)
   match (try (\_ RunnerInput (cast input) Nil Nil "" "" None 0) input)
     RunnerInput cmd vis env dir stdin predict pool =
       match (getOrElse defaultUsage (try (\_ None) predict))
         Usage status runtime cputime mem in out =
           def _ = launch job pool dir stdin env.implode cmd.implode status runtime cputime mem in out
           RunnerOutput (map getPathName vis) Nil Nil (getJobReality job)
  Runner doit

global def virtualRunner =
  def virtual job stdout stderr status runtime cputime membytes ibytes obytes = prim "job_virtual"
  def doit job input =
   # Ensure that match does not re-raise the exception (virtual must run)
   match (try (\_ RunnerInput (cast input) Nil Nil "" "" None 0) input)
     RunnerInput cmd vis env dir stdin predict pool =
       match (getOrElse defaultUsage (try (\_ None) predict))
         Usage status runtime cputime mem in out =
           # Make sure any exceptions get fed into virtual
           def stuff = implode (dir, stdin, str pool, cmd ++ env)
           def s = if stuff ==* "" then status else status
           def _ = virtual job "" "" s runtime cputime mem in out # sets predict+reality
           RunnerOutput (map getPathName vis) Nil Nil (getJobReality job)
  Runner doit

def implode l = cat (foldr (_, "\0", _) Nil l)
def runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool =
  def create dir stdin env cmd visible keep = prim "job_create"
  def finish job inputs outputs status runtime cputime membytes ibytes obytes = prim "job_finish"
  def cache dir stdin env cmd visible = prim "job_cache"
  def build _ =
    def doit job =
      def output = run job (RunnerInput cmd vis env dir stdin (getJobRecord job) pool)
      def final _ =
        # Make sure we run finish even if the runner raises an exception
        match (try (\_ RunnerOutput (cast output) (cast output) (cast output) (cast output)) output)
          RunnerOutput inputs outputs indexes usage =
            match (try (\_ defaultUsage) usage)
              Usage status runtime cputime mem in out =
                def input  = finputs  inputs  | map simplify | implode
                def output = foutputs outputs | map addhash  | implode
                finish job input output status runtime cputime mem in out
      # Make sure we don't hash files before the job has stopped running
      def _ = waitJobMerged final job
      job
    # Do not invoke the runner/finish if job create fails
    def rawjob = create dir stdin env.implode cmd.implode (map getPathName vis).implode (if keep then 1 else 0)
    reraise rawjob doit
  def confirm last job =
    def notOk (Pair name hash) = hashcode name !=* hash
    match (waitJobMerged (\_ find notOk last) job)
      None = job
      Some (Pair (Pair file saw) _) =
        raise "Hash mismatch for {file} ({saw} != {hashcode file}); remove it"
  match keep
    False = build 0
    True  = match (cache dir stdin env.implode cmd.implode (map getPathName vis).implode)
      Pair (job, _) last = confirm last job
      Pair Nil      last = confirm last (build 0)

# Only run if the first four arguments differ
def runOnce cmd env dir stdin finputs foutputs findexes vis keep share run pool =
  memoize 9 (runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool)

# Run the job!
global def runJob (Plan cmd vis env dir stdin once keep share (Runner run) finputs foutputs findexes pool) =
  if once
  then runOnce   cmd env dir stdin finputs foutputs findexes vis keep share run pool
  else runAlways cmd env dir stdin finputs foutputs findexes vis keep share run pool

def toUsage (Pair (Pair status runtime) (Pair (Pair cputime membytes) (Pair ibytes obytes))) =
  Usage status runtime cputime membytes ibytes obytes

def getJobReality =
  def raw job = prim "job_reality"
  raw _ | toUsage

def waitJobMerged f j =
  def raw job = prim "job_reality"
  raw j | waitOne f

# Actual usage of a finished job
global def getJobReport =
  def raw job = prim "job_report"
  raw _ | toUsage

# From database, available the moment a Job exists
global def getJobRecord =
  def raw job = prim "job_record"
  raw _ | atOpt 0 | omap toUsage

# Control a running/finished Job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
def fail job ok = if job.getJobStatus == 0 then ok else raise "Non-zero exit status ({str job.getJobStatus})"
global def killJob job signal = prim "job_kill" # s != 0 => kills; blocks till exit; return status
global def getJobStatus  job = getJobReport job | getUsageStatus
global def getJobStdout  job = stdio job 1
global def getJobStderr  job = stdio job 2
global def getJobInputs  job = fail job job.getJobFailedInputs
global def getJobOutputs job = fail job job.getJobFailedOutputs
global def getJobFailedInputs  job = tree job 1 | map getPairFirst | map Path
global def getJobFailedOutputs job = tree job 2 | map getPairFirst | map Path
global def getJobOutput = match _.getJobOutputs
  x, Nil = x
  Nil    = raise "no outputs available"
  _      = raise "more than one output found"

# Implement FUSE-based Runner
def wakePath = prim "execpath" # location of the wake executable
def fusePath = relative workspace (simplify "{wakePath}/../lib/wake/fuse-wake")
global def fuseRunner =
  def pre input =
    def cmd = fusePath, input.getRunnerInputDirectory, input.getRunnerInputVisible | map getPathName
    def fuse = makeRawPlan cmd | setPlanPool 0 | runJob
    def handle _ = raise "Could not start fuse-wake: {fuse.getJobStderr | tokenize "\n" | head}"
    def root = try handle (extract 'OK: (.*)' fuse.getJobStderr)
    Pair (editRunnerInputDirectory ("{root.head}/{_}") input) fuse
  def post (Pair output fuse) =
    def _ = killJob fuse 14 # SIGALRM
    def result = extract "(.*\0)?\0(.*)" fuse.getJobStdout
    def inputs  = result | at 0 | tokenize "\0" | reverse | tail
    def outputs = result | at 1 | tokenize "\0" | reverse | tail
    def usage (Usage ps pr pc pm pi po) = match fuse.getJobReport
      Usage fs _ fc fm fi fo =
        Usage (if fs == 0 then ps else fs) pr (fc +. pc) (fm + pm) (fi + pi) (fo + po)
    output
    | setRunnerOutputInputs  inputs
    | setRunnerOutputOutputs outputs
    | editRunnerOutputUsage usage
  makeRunner pre post manualRunner

# Paths differ from Strings in that they have been hashed; their content is frozen
data Path = Path String
global def getPathName (Path name) = name
global def getPathParent (Path name) = Path (simplify "{name}/..")

def addhash f =
  def p = simplify f
  def add f h = prim "add_hash"
  add p (hashcode p)

def hashcode f = memoize 0 (
  def get f = prim "get_hash"
  def reuse = get f
  if reuse !=* "" then reuse else
    def job = makeRawPlan ("<hash>", f, Nil) | runJob
    if job.getJobStatus == 0
    then extract '(.{64}).*' job.getJobStdout | head
    else raise "Failed to hash file {f}"
)

def stateRunner =
  def add f h = prim "add_hash"
  def hash = "0000000000000000000000000000000000000000000000000000000000000000"
  def pre input =
    match input.getRunnerInputCommand
      _, file, Nil = Pair input file
      _ = raise "stateRunner: invalid command-line"
  def post (Pair output file) =
    editRunnerOutputOutputs (add file hash, _) output
  makeRunner pre post virtualRunner

# Mark a file whose contents must not be tracked
global def makeStatePath file =
  makePlan ("<state>", file, Nil) Nil
  | setPlanRunner      stateRunner
  | setPlanKeep        False
  | setPlanEnvironment Nil
  | setPlanFnOutputs   (file, _)
  | runJob
  | getJobOutput

# Whenever possible, use 'job' if:
#   cmd can run under FUSE
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   gcc
# job only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def job cmd visible =
  makePlan cmd visible
  | runJob

# Use alwaysJob when:
#   cmd can run under FUSE
#   cmd output can differ between invocations
# Examples:
#   date
# alwaysJob only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def alwaysJob cmd visible =
  makePlan cmd visible
  | setPlanKeep False
  | runJob

# Use manualJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   vcs
# cmd will have access to the entire workspace.
# manualJob behaves like normal target rule in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may be rerun and wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def manualJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | runJob

# Use volatileJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd output can differ between invocations
# Examples:
#   ???
# volatileJob behaves like a PHONY target in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def volatileJob cmd visible foutputs =
  makeManualPlan cmd visible foutputs
  | setPlanKeep False
  | runJob
