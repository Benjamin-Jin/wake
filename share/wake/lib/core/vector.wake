# Vector type
data Slice a = Slice (Vector a) Integer Integer

# Convert List a => Vector a
global def lvector l =
  def llen = len l
  def vnew n = prim "vnew"
  # take out as an arg so vnew does not generalize
  def bind out =
    def vset o i v = prim "vset"
    def doit i v =
      def _ = vset out i v
      i+1
    def _ = foldl doit 0 l
    out
  Slice (bind (vnew llen)) 0 llen

global def tvector t =
  def len = tlen t
  def vnew n = prim "vnew"
  # take out as an arg so vnew does not generalize
  def bind out =
    def vset o i v = prim "vset"
    def f i x = vset out i x
    def _ = tappi f t
    out
  Slice (bind (vnew len)) 0 len

global def vempty (Slice _ s e) = s == e
global def vlen (Slice _ s e) = e - s
global def vlist = vfoldr (_,_) Nil

global def vsplitAt i (Slice v s e) =
  def x = min e (s + max 0 i)
  Pair (Slice v s x) (Slice v x e)

global def vtake i v = (vsplitAt i v).first
global def vdrop i v = (vsplitAt i v).second

global def vatOpt i (Slice v s e) =
  def get v i = prim "vget"
  def j = i+s
  if i >= 0 & j < e then Some (get v j) else None

global def vat i v = match (vatOpt i v)
  None   = raise "vat index out of bounds"
  Some x = x

def vat_ i (Slice v s _) =
  def get v i = prim "vget"
  get v (s+i)

global def vmap f v = vtab (\i f (vat_ i v)) (vlen v)
global def vseq n = vtab (_) n
global def vzip a b = vtab (\i Pair (vat_ i a) (vat_ i b)) (min (vlen a) (vlen b))
global def vunzip v =
  Pair (vtab (\i (vat_ i v).first) (vlen v)) (vtab (\i (vat_ i v).second) (vlen v))
global def vreverse v =
  def n = vlen v
  def n1 = n-1
  vtab (\i vat_ (n1-i) v) n

global def vfoldl f a v =
  def len = vlen v
  def helper a i =
    if i == len
    then a
    else helper (f a (vat_ i v)) (i+1)
  helper a 0

global def vfoldr f a v =
  def helper a i =
    if i == -1
    then a
    else helper (f (vat_ i v) a) (i-1)
  helper a (vlen v - 1)

global def vfoldmap f a g v =
  def len = vlen v
  def helper a s e =
    def mid = (e + s) >> 1
    def mid1 = mid + 1
    def b = g (vat_ mid v)
    def l = if mid  == s then a else helper a s mid
    def r = if mid1 == e then b else helper b mid1 e
    f l r
  if len == 0 then a else helper a 0 len

global def vfold f a v = vfoldmap f a (_) v

global def vfind f v =
  def len = vlen v
  def helper i =
    if i == len then None else
      def x = vat_ i v
      if f x then Some (Pair x i) else helper (i+1)
  helper 0

global def vsplitUntil f v =
  match (vfind f v)
    None = match v
      (Slice z _ _) = Pair v (Slice z 0 0)
    Some (Pair _ i) = vsplitAt i v

global def vtakeUntil f t = (vsplitUntil f t).first
global def vdropUntil f t = (vsplitUntil f t).second

# Returns True if there exists an x where f x = True
global def vexists f t = match (vfind f t)
  Some _ = True
  None   = False

global def vforall f t = !vexists (!f _) t

global def vsplitBy f v =
  def len = vlen v
  def vnew n = prim "vnew"
  def select = vmap f v
  def index = vscanmap (_+_) 0 (\x (if x then 1 else 0)) select
  def ntake = vat_ len index
  def ndrop = len - ntake
  def bind take drop =
    def vset o i v = prim "vset"
    def exec i =
      def t = vat_ i select
      def o = vat_ i index
      def x = vat_ i v
      if t then vset take o x else vset drop (i-o) x
    def _ = vappi exec len
    Pair (Slice take 0 ntake) (Slice drop 0 ndrop)
  bind (vnew ntake) (vnew ndrop)

global def vfilter f v = (vsplitBy f v).first

global def vscanl f a v =
  def len = vlen v
  def vnew n = prim "vnew"
  def bind out =
    def vset o i v = prim "vset"
    def helper a i =
      def _ = vset out i a
      if i == len
      then Unit
      else helper (f a (vat_ i v)) (i+1)
    def _ = helper a 0
    Slice out 0 (len+1)
  bind (vnew (len+1))

global def vscanr f a v =
  def len = vlen v
  def vnew n = prim "vnew"
  def bind out =
    def vset o i v = prim "vset"
    def helper a i =
      def _ = vset out i a
      def i1 = i - 1
      if i == 0
      then Unit
      else helper (f (vat_ i1 v) a) i1
    def _ = helper a len
    Slice out 0 (len+1)
  bind (vnew (len+1))

# !!! vscan = O(n), log n deep prefix-sum
# f called exactly once
global def vscanmap f a g v = vscanl f a (vmap g v)
global def vscan f a v = vscanmap f a (_) v

# !!! sortBy O(n) if sorted
global def vsortBy lt v = lvector (sortBy lt (vlist v))

global def vdistinctBy eq v =
  def keep i =
    def vi = vat_ i v
    if i == 0 then Some vi else
      def vi1 = vat_ (i-1) v
      if eq vi1 vi then None else Some vi
  vmapPartial (_) (vtab keep (vlen v))

global def vcollate f l r =
  def len = min (vlen l) (vlen r)
  def helper i =
    if i == len then
      cmp (vlen l) (vlen r)
    else match (f (vat_ i l) (vat_ i r))
      EQ = helper (i+1)
      x  = x
  helper 0

global def vtranspose v =
  def outer i = vmapPartial (vatOpt i _) v
  vtab outer (vfoldmap max 0 vlen v)

global def vflatten vo =
  def leno = vlen vo
  def offset = vscanmap (_+_) 0 vlen vo
  def flat = vat_ leno offset
  def vnew n = prim "vnew"
  def bind out =
    def vset o i v = prim "vset"
    def outer o =
      def vi   = vat_ o vo
      def base = vat_ o offset
      def leni = vlen vi
      def inner i = vset out (base+i) (vat_ i vi)
      vappi inner leni
    def _ = vappi outer leno
    Slice out 0 flat
  bind (vnew flat)

# Simple parallel construction
global def vtab f n =
  def vnew n = prim "vnew"
  def bind out =
    def vset o i v = prim "vset"
    def _ = vappi (\i vset out i (f i)) n
    Slice out 0 n
  bind (vnew n)

# f will be called more than once per element
def vmapPartial f v =
  def intSome x = match (f x)
    Some _ = 1
    None   = 0
  def dest = vscanmap (_+_) 0 intSome v
  def leni = vlen v
  def leno = vat_ leni dest
  def vnew n = prim "vnew"
  def bind out =
    def vset o i v = prim "vset"
    def exec i = match (f (vat_ i v))
      Some x = vset out (vat_ i dest) x
      None   = True
    def _ = vappi exec leni
    Slice out 0 leno
  bind (vnew leno)

def vappi f n =
  def helper s e =
    def mid = (s + e) >> 1
    def mid1 = mid + 1
    def _ = f mid
    def _ = if mid  == s then Unit else helper s mid
    def _ = if mid1 == e then Unit else helper mid1 e
    Unit
  if n == 0 then Unit else helper 0 n
